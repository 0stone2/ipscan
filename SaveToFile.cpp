// SaveToFile.cpp: implementation of the CSaveToFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ipscan.h"
#include "IpscanDlg.h"
#include "SaveToFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaveToFile::CSaveToFile(CIpscanDlg *dlg, BOOL bSaveSelection, LPSTR szFileName, int nFileFormat, BOOL bAppend)
{
	m_dlg = dlg;

	m_bAppend = bAppend;
	
	if (dlg->m_list.GetItemCount() == 0) 
	{
		dlg->MessageBox("The list is empty!",NULL,MB_OK | MB_ICONHAND);
		return;
	}

	m_saveselection = bSaveSelection;
	if (bSaveSelection && dlg->m_list.GetSelectedCount()==0)
	{		
		dlg->MessageBox("You must select some items first!",NULL,MB_OK | MB_ICONHAND);
		return;
	}
	
	BOOL bResult;
	
	if (szFileName == NULL) 
	{
		bResult = queryFilename();
	}
	else
	{
		bResult = TRUE;
		m_filename = szFileName;
	}

	if (nFileFormat >= 0) 
		m_filetype = nFileFormat;
	
	if (bResult)
	{
		// Start saving!
		m_dlg->status("Exporting...");

		FILE *fileHandle;
		if (m_bAppend)
			fileHandle = fopen(m_filename,"at");
		else
			fileHandle = fopen(m_filename,"wt");
	
		if (!fileHandle) 
		{
			m_dlg->MessageBox("Cannot open file for writing", NULL, MB_OK | MB_ICONHAND);
			return;
		}	

		switch (m_filetype)
		{	
			case FILE_TYPE_CSV:
				saveToCSV(fileHandle);
				break;
			case FILE_TYPE_HTML:
				saveToHTML(fileHandle);
				break;
			default:
				saveToTXT(fileHandle);
		}		

		// At this point the file has been processed
		fclose(fileHandle);

		// Open the newly saved file only if run by user (not command-line)
		if (szFileName == NULL)
		{
			ShellExecute(0, "open", m_filename, NULL, NULL, SW_SHOWNORMAL);
		}

		m_dlg->status(NULL);
	}
		
}

CSaveToFile::~CSaveToFile()
{
	
}

void CSaveToFile::saveToTXT(FILE *fileHandle)
{	
	CString szHomepage;
	szHomepage.LoadString(IDS_HOMEPAGE);

	if (!m_bAppend)
	{
		fputs("This file was generated by Angry IP Scanner\n"
			  "Visit " + szHomepage + " for the latest version\n\n", fileHandle);
	}

	fputs("Scanned ", fileHandle);
	in_addr inAddr;	
	inAddr.S_un.S_addr = htonl(g_nStartIP); fputs(inet_ntoa(inAddr), fileHandle);
	fputs(" - ", fileHandle);
	inAddr.S_un.S_addr = htonl(g_nEndIP); fputs(inet_ntoa(inAddr), fileHandle);
	if (g_options->m_bScanPorts)
	{
		fputs(" (Ports: " + g_options->m_szPorts + ")", fileHandle);
	}
	fputs("\n" + g_options->getCurrentDate() + "\n\n", fileHandle);
	
	int i,j;
	int ws[100];

	CString tmp;
	LV_ITEM it;

	// Output column names
	
	for (i=0; i < g_scanner->getColumnCount(); i++) 
	{
		ws[i] = m_dlg->m_list.GetColumnWidth(i) / 8 + 10;
		
		if (!m_bAppend)
		{			
			g_scanner->getColumnName(i, tmp);
			fprintf(fileHandle,"%-*s",ws[i],tmp);
		}
	}

	if (g_options->m_bScanPorts)
	{
		fprintf(fileHandle,"%s","Open Ports");
	}

	if (!m_bAppend)
		fputs("\n\n", fileHandle);
	

	// Output data
	if (m_saveselection)
	{
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{
			it.mask = LVIF_STATE; 
			it.stateMask = LVIS_SELECTED;
			it.iItem = i; 
			it.iSubItem = CL_IP; 

			m_dlg->m_list.GetItem(&it); 
			if (it.state != LVIS_SELECTED) continue;

			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "%-*s",ws[j], m_dlg->m_list.GetItemText(i,j));
			}
			
			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, "%s", szPorts);
			}

			fputs("\n", fileHandle);
		}
	}
	else  // save all, not only selected items
	{
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{					
			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "%-*s",ws[j], m_dlg->m_list.GetItemText(i,j));
			}

			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, "%s", szPorts);
			}

			fputs("\n", fileHandle);
		}
	}	
}

void CSaveToFile::saveToHTML(FILE *fileHandle)
{
	CString szHomepage;
	szHomepage.LoadString(IDS_SCAN_HOMEPAGE);

	if (m_bAppend)
	{
		m_dlg->MessageBox("Appending to HTML files is not supported!", NULL, MB_OK | MB_ICONHAND);
		return;
	}
	
	// Output HTML head
	fputs("<html>\n<head>\n", fileHandle);
	fputs("<title>Angry IP Scanner: scanning results</title>\n", fileHandle);

	// some CSS magic ;-)
	fputs("<style>body, td { font-family: arial; font-size: 12px; }  </style>\n", fileHandle);

	fputs("<meta name=\"Generator\" content=\"Angry IP Scanner, " + szHomepage + "\">", fileHandle);
	fputs("</head>\n", fileHandle);
	
	// The BODY!
	fputs("<body>\n", fileHandle);
	
	// beginning	
	fputs("<h4>Scanned ", fileHandle);	
	in_addr inAddr;	
	inAddr.S_un.S_addr = htonl(g_nStartIP); fputs(inet_ntoa(inAddr), fileHandle);
	fputs(" - ", fileHandle);
	inAddr.S_un.S_addr = htonl(g_nEndIP); fputs(inet_ntoa(inAddr), fileHandle);
	if (g_options->m_bScanPorts)
	{
		fputs(" (Ports: " + g_options->m_szPorts + ")", fileHandle);
	}
	fputs("</h4>\n", fileHandle);
	fputs(g_options->getCurrentDate() + "<br><br>\n", fileHandle);

	// the table
	fputs("<table border=\"1\" cellspacing=\"0\" cellpadding=\"2\">\n<tr>\n", fileHandle);
	
	int i,j;	

	CString tmp;
	LV_ITEM it;

	// Output column names
	for (i=0; i < g_scanner->getColumnCount(); i++) 
	{			
		g_scanner->getColumnName(i, tmp);			
		fprintf(fileHandle, "<td><b>%s</b></td>\n", tmp);
	}	

	if (g_options->m_bScanPorts)
	{
		fputs("<td><b>Open Ports</b></td>\n", fileHandle);
	}	
	
	// Output data
	if (m_saveselection)
	{
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{
			fputs("</tr>\n<tr>\n", fileHandle);

			it.mask = LVIF_STATE; 
			it.stateMask = LVIS_SELECTED;
			it.iItem = i; 
			it.iSubItem = CL_IP; 

			m_dlg->m_list.GetItem(&it); 
			if (it.state != LVIS_SELECTED) continue;

			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "<td>%s</td>\n", m_dlg->m_list.GetItemText(i,j));
			}
			
			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, "<td>%s</td>", szPorts);
			}			
		}
	}
	else  // save all, not only selected items
	{
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{					
			fputs("</tr>\n<tr>\n", fileHandle);

			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "<td>%s</td>", m_dlg->m_list.GetItemText(i,j));
			}

			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, "<td>%s</td>", szPorts);
			}
		}
	}		

	// Finish the html
	fputs("</tr>\n", fileHandle);
	fputs("</table>\n", fileHandle);
	fputs("<br><br>Generated by <a href=\"" + szHomepage+ "\">Angry IP Scanner</a>\n", fileHandle);
	fputs("</body>\n</html>\n", fileHandle);
}

void CSaveToFile::saveToCSV(FILE *fileHandle)
{
	int i,j;	

	CString tmp;	
	LV_ITEM it;

	// Output data
	if (m_saveselection)
	{
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{
			it.mask = LVIF_STATE; 
			it.stateMask = LVIS_SELECTED;
			it.iItem = i; 
			it.iSubItem = CL_IP; 

			m_dlg->m_list.GetItem(&it); 
			if (it.state != LVIS_SELECTED) continue;

			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "%s", m_dlg->m_list.GetItemText(i,j));
				if (j < g_scanner->getColumnCount() -1) fputs(",", fileHandle);
			}

			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, ",%s", szPorts);
			}

			fputs("\n", fileHandle);
		}
	}
	else  // save all, not only selected items
	{		
		for (i=0; i < m_dlg->m_list.GetItemCount(); i++) 
		{
			for (j=0; j < g_scanner->getColumnCount(); j++) 
			{
				fprintf(fileHandle, "%s", m_dlg->m_list.GetItemText(i,j));
				if (j < g_scanner->getColumnCount() - 1) fputs(",", fileHandle);
			}

			if (g_options->m_bScanPorts)
			{
				CString szPorts;
				m_dlg->m_list.GetOpenPorts(i, szPorts);
				fprintf(fileHandle, ",%s", szPorts);
			}

			fputs("\n", fileHandle);
		}
	}

	
}

BOOL CSaveToFile::queryFilename()
{
	CFileDialog fd(FALSE,"txt",NULL,OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
		"Text files (*.txt)|*.txt|"
		"Comma-separated files (*.csv)|*.csv|"
		"HTML files (*.htm*)|*.htm*||", 
		m_dlg);

	if (fd.DoModal() == IDOK)
	{		
		CString szFileExt = fd.GetFileExt();		

		if (szFileExt.CompareNoCase("csv") == 0)
		{
			m_filetype = FILE_TYPE_CSV;
		}
		else if (szFileExt.Mid(0, 3).CompareNoCase("htm") == 0)	// Allow both *.htm & *.html
		{
			m_filetype = FILE_TYPE_HTML;			
		}
		else
		{
			m_filetype = FILE_TYPE_TXT;
		}

		m_filename = fd.GetPathName();

		return TRUE;
	}
	else
	{
		return FALSE;
	}	

}


